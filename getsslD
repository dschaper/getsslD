#!/bin/ash
# ---------------------------------------------------------------------------
# getsslD - Obtain SSL certificates from the letsencrypt.org ACME server.
#           Runs in a Docker conatainer.
#           Based on the work of getssl by srvrco https://github.com/srvrco/getssl
#           and acme.sh by Neil Pang http://Neilpang/acme.sh

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.

PROGNAME=getsslD
VERSION="1.0"

# Default values, accepts environment variables if set, otherwise default are used
WORKING_DIR=${WORKING_DIR:="/ssl}"
ACCOUNT_KEY_LENGTH=${ACCOUNT_KEY_LENGTH:="4096"}
ACCOUNT_KEY_TYPE=${ACCOUNT_KEY_TYPE:="rsa"}
ACCOUNT_KEY=${ACCOUNT_KEY:="$WORKING_DIR/account.key"}


#####
# Functions
#####

create_account_key() {
  # Create account key

  # Set values to args otherwise use environment variables
  # https://stackoverflow.com/a/13864829
  if [[ ! -z ${1+x} ]]; then
    ACCOUNT_KEY_LENGTH="${1}"
  fi
  if [[ ! -z ${2+x} ]]; then
    ACCOUNT_KEY="${2}"
  fi
  if [[ -s ${ACCOUNT_KEY} ]]; then
    printf '%s\n' "Account key exists at ${ACCOUNT_KEY} skipping generation."
    return 0
  elif [[ ! -d $(dirname "${2}") ]]; then
    print_error "Directory for storing ${2} does not exist."
    return 1
  else
    printf '%s\n' "Creating account key ${ACCOUNT_KEY}:"
    create_key "${ACCOUNT_KEY}" "${ACCOUNT_KEY_LENGTH}"
  fi
  return 0
}

create_key() {
  # Create an openSSL key

  local key_loc=${1}
  local key_len=${2}
  local key_type

  # Determine key type by length
  # Valid Let's Encrypt RSA key lengths 2048-4096
  # Valid Let's Encrypt ECC key lengths 256, 384, 521*(Not implemented)

  if [[ "${key_len}" -ge 2048 ]] && [[ "${key_len}" -le 4096 ]]; then
    key_type="RSA"
  elif [[ "${key_len}" -eq 256 ]]; then
    key_type="prime256v1"
  elif [[ "${key_len}" -eq 384 ]]; then
    key_type="secp384r1"
  elif [[ "${key_len}" -eq 521 ]]; then
    key_type="secp521r1"
  else
    print_error "Invalid key length. Please check your configuration."
    return 1
  fi

  case "$key_type" in
    RSA)
      printf '\t%s' "Creating ${key_len} bit RSA key..."
      openssl genrsa -out "${key_loc}" "${key_len}" >& /dev/null
      printf '%s\n' "Done."
      return 0
      ;;
    prime256v1|secp384r1|secp521r1)
      printf '\t%s' "Creating ${key_len} bit ECC key..."
      openssl ecparam -genkey -out "${key_loc}" -name "${key_type}" >& /dev/null
      printf '%s\n' "Done."
      return 0
      ;;
  esac

  # Error inside case statement openssl generation
  print_error "Error creating OpenSSL key, deleting key..."
  rm "${key_loc}"
  print_error "Done.\n"
  return 1
}

get_date() {
  # get current date and time in UTC YYYY-MM-DDTHH:MM:SSZ
  echo $(date -u +"%Y-%m-%dT%H:%M:%SZ")
}

help_message() {
  # Print help message

  cat <<- _EOF_
  Usage: "${PROGNAME}" [OPTION]... [ARGS]...
  Obtain SSL certificates from the letsencrypt.org ACME server.

  Options to long options apply to short options also.
  Options:
    -a, --account [LENGTH] [FILE]   Create an account key of LENGTH with FILE name.
                                      LENGTH is 2048-4096 for RSA keys, 256|384|521 for ECC keys.
                                        Defaults to 4096 bit RSA key in account.key.
	_EOF_
	return 0
}

prep_workdir() {
  # Prepare working directory for key/cert functions

  if [[ ! -d "${WORKING_DIR}" ]]; then
    printf '%s' "Creating getsslD certificate storage directory - ${WORKING_DIR}..."
    if ! mkdir -p "${WORKING_DIR}" >& /dev/null; then
      print_error "Could not create ${WORKING_DIR}. Check volumes.\n"
      exit 1
    else
      printf '%s\n' "Done."
    fi
  fi
  return 0
}

print_error() {
  # Output error messages to STDERR
  local error=$1

  printf '!! %s\n' "${1}" 1>&2
  return 0
}

arg_parser() {
  # Check CLI arguments and process

  while [[ -n ${1} ]]; do
    case $1 in
      -a | --account)
        shift
        create_account_key $*
        exit 0
        ;;
      -h | --help)
        help_message;
        exit 0
        ;;
      *)
        printf '%s\n\n' "Invalid option."
        help_message
        exit 1
        ;;
    esac
    shift
    if [[ -z ${1} ]]; then
      break
    fi
  done
}

#####
# Main logic
#####

main() {

# read any variables from config in working directory
if [[ -s "$WORKING_DIR/getsslD.cfg" ]]; then
  debug "reading config from $WORKING_DIR/getsslD.cfg"
  # shellcheck source=/dev/null
  . "$WORKING_DIR/getsslD.cfg"
fi

arg_parser $*

}

# Only run main if we are not testing.
if [[ "${GETSSLD_TEST}" != true ]]; then
  main $@
fi
